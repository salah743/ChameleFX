from __future__ import annotations
from pathlib import Path
from typing import Any, Dict
import json, time, threading

# Try shared atomic utils; fall back to local
try:
    from chamelefx.utils.atomic_json import read_json, write_json_atomic
except Exception:
    from ._atomic_local import read_json, write_json_atomic  # type: ignore

ROOT = Path(__file__).resolve().parents[1]
RUN  = ROOT / "runtime"
RUN.mkdir(parents=True, exist_ok=True)

OUTBOX = RUN / "orders_outbox.json"
LOGF   = RUN / "exec_log.jsonl"

# Client may or may not be present
_mt5 = None
try:
    from chamelefx.integrations import mt5_client as _mt5
except Exception:
    _mt5 = None

_state = {"connected": False, "last_ping_ok": False, "last_error": "", "last_ping_ts": 0.0, "account": {}}
_lock = threading.Lock()

def _ensure_outbox():
    if not OUTBOX.exists():
        write_json_atomic(OUTBOX, {"pending": [], "sent": []})

def _coid(order: dict) -> str:
    b = int(time.time() // 30)
    return order.get("client_order_id") or f"{order.get('symbol','?')}-{order.get('side','?')}-{order.get('qty',0)}-{order.get('price','')}-{b}"

def _append_log(row: dict):
    try:
        LOGF.parent.mkdir(parents=True, exist_ok=True)
        LOGF.open("a", encoding="utf-8").write(json.dumps(row)+"\n")
    except Exception:
        pass

def status() -> dict:
    with _lock:
        s = dict(_state)
    return {"ok": True, **s, "mt5_available": bool(_mt5)}

def connect() -> dict:
    with _lock:
        if _mt5 is None:
            _state.update({"connected": False, "last_error": "mt5_unavailable"})
            return {"ok": False, "error": "mt5_unavailable"}
        try:
            ok = _mt5.connect()
            _state["connected"] = bool(ok)
            _state["last_error"] = "" if ok else "connect_failed"
            return {"ok": bool(ok)}
        except Exception as e:
            _state.update({"connected": False, "last_error": repr(e)})
            return {"ok": False, "error": repr(e)}

def ping() -> dict:
    with _lock:
        if _mt5 is None:
            _state.update({"last_ping_ok": False, "last_error": "mt5_unavailable", "last_ping_ts": time.time()})
            return {"ok": False, "mt5": "unavailable"}
        try:
            acct = _mt5.account_summary()
            _state["account"] = acct or {}
            _state["last_ping_ok"] = True if acct else False
            _state["connected"] = True if acct else _state["connected"]
            _state["last_ping_ts"] = time.time()
            return {"ok": bool(acct), "account": acct}
        except Exception as e:
            _state["last_ping_ok"] = False
            _state["last_error"] = repr(e)
            _state["last_ping_ts"] = time.time()
            try:
                _mt5.connect()
            except Exception:
                pass
            return {"ok": False, "error": repr(e)}

def _send(order: dict) -> dict:
    if _mt5 is None:
        return {"ok": False, "error": "mt5_unavailable"}
    side = order.get("side","buy").lower()
    typ  = order.get("type","market").lower()
    sym  = order.get("symbol","")
    qty  = float(order.get("qty",0))
    price = order.get("price")
    sl = order.get("sl"); tp = order.get("tp")
    if typ == "market":
        return _mt5.place_market(symbol=sym, side=side, qty=qty, sl=sl, tp=tp)
    else:
        return _mt5.place_pending(symbol=sym, side=side, qty=qty, price=price, typ=typ, sl=sl, tp=tp)

def _already_sent(ob: dict, coid: str) -> bool:
    for r in ob.get("sent", []):
        if r.get("client_order_id") == coid:
            return True
    return False

def place_order(order: dict, attempts: int = 3) -> dict:
    with _lock:
        _ensure_outbox()
        coid = _coid(order)
        order["client_order_id"] = coid
        ob = read_json(OUTBOX, {"pending": [], "sent": []})
        if _already_sent(ob, coid):
            return {"ok": True, "status": "duplicate_ignored", "client_order_id": coid}
        if not any(p.get("client_order_id")==coid for p in ob["pending"]):
            ob["pending"].append(order); write_json_atomic(OUTBOX, ob)

        backoff = 0.3; last_err = ""
        for _ in range(attempts):
            try:
                res = _send(order)
                if res and res.get("ok"):
                    ob = read_json(OUTBOX, {"pending": [], "sent": []})
                    ob["pending"] = [p for p in ob["pending"] if p.get("client_order_id") != coid]
                    sent_row = dict(order); sent_row.update({"result": res, "ts": time.time(), "sent": True})
                    ob.setdefault("sent", []).append(sent_row)
                    write_json_atomic(OUTBOX, ob)
                    _append_log({"ts": time.time(), "event":"order_sent", "coid": coid, "res": res})
                    return {"ok": True, "client_order_id": coid, "result": res}
                last_err = repr(res)
            except Exception as e:
                last_err = repr(e)
            time.sleep(backoff); backoff *= 2
        _append_log({"ts": time.time(), "event":"order_failed", "coid": coid, "error": last_err})
        return {"ok": False, "client_order_id": coid, "error": last_err}

def cancel_order(broker_order_id: str) -> dict:
    with _lock:
        try:
            if _mt5 is None: return {"ok": False, "error": "mt5_unavailable"}
            return _mt5.cancel_order(broker_order_id) or {"ok": False}
        except Exception as e:
            return {"ok": False, "error": repr(e)}

def outbox() -> dict:
    with _lock:
        _ensure_outbox()
        ob = read_json(OUTBOX, {"pending": [], "sent": []})
        return {"ok": True, "pending": ob.get("pending", []), "sent_count": len(ob.get("sent", []))}

def flush_pending(max_items: int = 10) -> dict:
    with _lock:
        _ensure_outbox()
        ob = read_json(OUTBOX, {"pending": [], "sent": []})
        todo = ob.get("pending", [])[:max_items]
    results = [place_order(o) for o in todo]
    return {"ok": True, "results": results}
